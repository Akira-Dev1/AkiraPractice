# Задача 9: Функция. Валидатор судоку.
## Условие задачи:
Дан код, который принимает на вход матрицу из 9 строк по 9 цифр в каждой строке. Каждая цифра может быть из диапазона от 1 до 9 включительно. Код должен проверить, является ли матрица решением судоку:

```go
package main
import "fmt"

const rows int = 9
const cols int = 9

// Ваш код будет вставлен сюда

func main() {
    var bord [rows][cols]int
    
    for row:=0; row < rows; row++ {
        for col:=0; col < cols; col++ {
            fmt.Scanf("%c", &bord[row][col])  // Считываем один символ
            bord[row][col] -= '0'  // Чтобы из ASCII кода символа получить цифру
        }
        fmt.Scanf("\n")
    }
    
    if isValidSudoku(bord){
        fmt.Println("YES")
    }else{
        fmt.Println("NO")
    }
}

```
Этот код будет прогоняться по тестам. Ваша задача реализовать функцию isValidSudoku таким образом, чтобы код стал рабочим.

### Формат ввода
Девять строк текста. Каждая строка состоит из 9ти символов и заканчивается символом \n. Каждый символ в строке может быть одним из диапазона от 1 до 9 включительно.
### Формат вывода
YES, если ввод это валидное судоку или NO, если нет.
## Решение:
```go
func isValidSudoku(bord [9][9]int) bool {
	for x := 0; x < 9; x++ {
		a := make(map[int]bool)
		for _, r := range bord[x] {
			if a[r] {
				return false
			}
			a[r] = true
		}
	}
	for x := 0; x < 9; x++ {
		a := make(map[int]bool)
		for i := 0; i < 9; i++ {
			r := bord[i][x]
			if a[r] {
				return false
			}
			a[r] = true
		}
	}
	for x := 0; x <= 6; x += 3 {
		for y := 0; y <= 6; y += 3 {
			a := make(map[int]bool)
			for x1 := 0; x1 <= 2; x1++ {
				for y1 := 0; y1 <= 2; y1++ {
					r := bord[x+x1][y+y1]
					if a[r] {
						return false
					}
					a[r] = true
				}
			}
		}
	}
	return true
}
```
## Пояснение решения:
1. Проверка строк:
```go
	for x := 0; x < 9; x++ {
		a := make(map[int]bool)
		for _, r := range bord[x] {
			if a[r] {
				return false
			}
			a[r] = true
		}
	}
```
Пояснение:
 - Проходим по каждой строки x матрицы bord.
 - a := make(map\[int]bool) создаёт словарь для проверки повторов цифр в строке.
 - Внутренний цикл for _, r := range bord\[x] перебирает все числа в строке.
 - Если число уже встречалось (a\[r] == true) → возвращаем false.
 - Если нет — помечаем его как встреченное.
Идея: в каждой строке все цифры от 1 до 9 должны быть уникальными.
2. Проверка столбцов:
```go
	for x := 0; x < 9; x++ {
		a := make(map[int]bool)
		for i := 0; i < 9; i++ {
			r := bord[i][x]
			if a[r] {
				return false
			}
			a[r] = true
		}
	}
```
Пояснение:
 - Цикл перебирает каждый столбец x.
 - Создаём новый словарь a для проверки уникальности.
 - Внутренний цикл i проходит по строкам, чтобы взять bord\[i][x] — элемент столбца.
 - Проверяем, встречалось ли число раньше. Если да → false.
 - Иначе помечаем как встреченное.
Идея: в каждом столбце все цифры должны быть уникальными.
3. Проверка 3×3 блоков:
```go
	for x := 0; x <= 6; x += 3 {
		for y := 0; y <= 6; y += 3 {
			a := make(map[int]bool)
			for x1 := 0; x1 <= 2; x1++ {
				for y1 := 0; y1 <= 2; y1++ {
					r := bord[x+x1][y+y1]
					if a[r] {
						return false
					}
					a[r] = true
				}
			}
		}
	}
```
Пояснение:
 - Циклы x и y идут с шагом 3, чтобы пробежаться по каждому левому верхнему углу 3×3 блока.
 - a := make(map\[int]bool) создаёт словарь для блока.
 - Внутренние циклы x1, y1 перебирают элементы текущего блока.
 - Если число повторяется → false.
 - Иначе помечаем как встреченное.
Идея: в каждом 3×3 блоке все цифры уникальны.
4. Успешная проверка:
```go
	return true
```
Пояснение:
 - Если проверки строк, столбцов и блоков прошли без возврата false, значит, судоку валидное → возвращаем true.
