# Задача 5: Функция. Сумма дробей.
## Условие задачи:
Дан код, который принимает на вход 2 [дроби](https://ru.wikipedia.org/wiki/%D0%94%D1%80%D0%BE%D0%B1%D1%8C_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)), складывает их и выводит получившееся число на экран (тоже в виде дроби).
Известно, что: Числитель - любое целое число; Знаменатель - целое положительное число.

```cpp
#include <iostream>
#include <tuple>

// Ваш код будет вставлен сюда

int main() {
    int m1, n1, m2, n2;
    char _;
    std::cin >> m1 >> _ >> n1
             >> m2 >> _ >> n2;
    std::tie(m1, n1) = reduce(m1, n1);
    std::tie(m2, n2) = reduce(m2, n2);

    auto[lcm, c1, c2] = find_lcm(n1, n2);
    auto[m, n] = reduce(m1 * c1 + m2 * c2, lcm);

    std::cout << m << '/' << n << std::endl;
}
```
Этот код будет прогоняться по тестам. Ваша задача реализовать функции reduce и find_lcm таким образом, чтобы этот код стал рабочим.

Функция reduce - сокращает дробь и приводит её к несократимому виду. Принимает на вход, числитель и знаменатель дроби, возвращает их же (и в том же порядке), но уже после сокращения.
```
// m == 5; n == 15;
std::tie(m, n) = reduce(m, n);
// m == 1; n == 3
```
Функция find_lcm - принимает 2 целых положительных числа и определяет их наименьшее общее кратное (НОК), а также множители, на которые нужно домножить первое и второе число соответственно, чтобы они стали равны НОК. Порядок возвращаемых значений: НОК, сомножитель для первого аргумента, сомножитель для второго аргумента.

```
// a == 66; b == 14;
auto[lcm, c, d] = find_lcm(a, b);
// lcm == 462; с == 7; d == 33
// a*c == b*d == lcm
```

### Формат ввода
Две дроби разделённые пробелом. Каждая из дробей вводится в формате: числитель символ / знаменатель, без пробелов и других разделителей.

Числитель - целое число −2 * 10⁹ ≤ m ≤ 2 * 10⁹; Знаменатель: 0 < n ≤ 2 * 10⁹. 
### Формат вывода
Дробь в формате: числитель символ / знаменатель, без пробелов и других разделителей.
## Решение:
```cpp
#include <iostream>
#include <tuple>
#include <cmath>
using namespace std;

pair<int, int> reduce(int m, int n) {
    int a = abs(m);
    int b = abs(n);
    while (b != 0) {
        int x = b;
        b = a % b;
        a = x;
    }
    return {m/a, n/a};
}

tuple<int, int, int> find_lcm(int n1, int n2) {
    int a = n1, b = n2;
    while (b != 0) {
        int t = b;
        b = a % b;
        a = t;
    }
    int gcd = a;
    int lcm = n1 / gcd * n2;
    int c1 = lcm / n1;
    int c2 = lcm / n2;
    return {lcm, c1, c2};
}
```
## Пояснение решения:
Библеотеки:
 - \<iostream\> - Нужно для ввода/вывода.
 - \<vector\> — чтобы хранить лабиринт в виде динамического массива строк.
 - \<string\> — для работы со строками, потому что лабиринт представлен как vector\<string\>.
 - \<tuple\> - Нужна, чтобы возвращать несколько значений из функции сразу. Пример: return {lcm, c1, c2};
 - \<cmath\> - Даёт доступ к математическим функциям, в нашем случае используется: abs(). Она возвращает модуль числа.

### reduce(int m, int n):
1. Подготовка:
```cpp
int a = abs(m);
int b = abs(n);
```
Пояснение:
 - Берём модуль числителя и знаменателя,
чтобы алгоритм Евклида (поиск НОД) работал корректно даже при отрицательных m.
2. НОД через алгоритм Евклида:
```cpp
while (b != 0) {
    int x = b;
    b = a % b;
    a = x;
}
```
Пояснение:
 - Как он работает:
a = 6, b = 9
1. a = 6, b = 9
 - → a % b = 6
 - → a = 9, b = 6
2. a = 9, b = 6
 - → a % b = 3
 - → a = 6, b = 3
3. a = 6, b = 3
 - → a % b = 0
 - → a = 3, b = 0

Итог: gcd = 3
3. Cокращаем дробь:
```cpp
return {m / a, n / a};
```
Пояснение:
 - Мы делим числитель и знаменатель на найденный НОД.

### find_lcm(int n1, int n2):
1. Ищем НОД:
```cpp
int a = n1, b = n2;
while (b != 0) {
    int t = b;
    b = a % b;
    a = t;
}
int gcd = a;
```
Пояснение:
 - Тот же алгоритм Евклида.
2. Вычисляем НОК:
```cpp
int lcm = n1 / gcd * n2;
```
3. Находим множители:
```cpp
int c1 = lcm / n1;
int c2 = lcm / n2;
```
Пример:
lcm = 462
c1 = 462 / 66 = 7
c2 = 462 / 14 = 33
Значит:
 - первую дробь надо домножить на 7,
 - вторую — на 33.
Теперь обе дроби будут иметь знаменатель 462.
4. Возвращаем результат:
```cpp
return {lcm, c1, c2};
```
