# Задача 10: Функция. Сапёр (поле).
## Условие задачи:
Реализуйте функцию fill которая заполняет значениями поле для игры [сапёр](https://ru.wikipedia.org/wiki/%D0%A1%D0%B0%D0%BF%D1%91%D1%80_(%D0%B8%D0%B3%D1%80%D0%B0)).

Функция должна принимать двумерный срез целых чисел ([][]int) в котором на месте мин указаны -1, а все оставшиеся ячейки равны нулю и заполнять его по следующему принципу:

 - в каждой ячейке должно быть указано, сколько мин в соседних 8-ми ячейках (вокруг текущей);
 - в заминированных ячейках должны остаться -1.
Этот код будет прогоняться по тестам. Ваша задача реализовать функцию fill таким образом, чтобы этот код стал рабочим.
```go
package main

import "fmt"

// Ваш код здесь

func main() {
    var rows, cols int
    fmt.Scanf("%d %d\n", &rows, &cols)
    
    // Создаём срез и заполняем его данными о расположении мин
    maze := make([][]int, rows, rows)
    for i := range maze {
        maze[i] = make([]int, cols, cols)
        for j := range maze[i] {
            fmt.Scanf("%d", &maze[i][j])
        }
    }
    
    // Заполняем игровое поле подсказками
    fill(maze)
    
    // Выводим на экран
    for _, row := range maze {
         for _, cell := range row {
             fmt.Printf("%3d", cell)
        }
        fmt.Println()
    }
}
```

### Формат ввода
В первой строке указаны два целых числа через пробел 3 ≤ rows, cols ≤ 100 - количество строк и столбцов в игровом поле соответственно.

В последующих rows строках указаны по cols целых чисел (0 или -1). Числа разделены одним или двумя пробелами.
### Формат вывода
Вывести игровое поле в rows строках по cols чисел в каждой. Числа должны быть выровнены в столбцы по 3 символа с пробелом в качестве заполнителя.
## Решение:
```go
func fill(maze [][]int) {
	rows := len(maze)
	cols := len(maze[0])
	for x := 0; x < rows; x++ {
		for y := 0; y < cols; y++ {
			if maze[x][y] == -1 {
				continue
			}
			count := 0
			for sx := -1; sx <= 1; sx++ {
				for sy := -1; sy <= 1; sy++ {
					nx := x + sx
					ny := y + sy
					if nx >= 0 && nx < rows && ny >= 0 && ny < cols {
						if maze[nx][ny] == -1 {
							count++
						}
					}
				}
			}
			maze[x][y] = count
		}
	}
}
```
## Пояснение решения:
1. Размеры поля:
```go
	rows := len(maze)
	cols := len(maze[0])
```
Пояснение:
 - rows — количество строк в игровом поле.
 - cols — количество столбцов.
 - Используем для ограничения индексов, чтобы не выйти за границы массива.
2. Обход всех ячеек:
```go
	for x := 0; x < rows; x++ {
		for y := 0; y < cols; y++ {
```
Пояснение:
 - Два вложенных цикла перебирают каждую ячейку матрицы maze\[x][y].
 - x — индекс строки, y — индекс столбца.
3. Пропускаем заминированные ячейки:
```go
    if maze[x][y] == -1 {
        continue
    }
```
Пояснение:
 - Если текущая ячейка уже содержит мину (-1), ничего не делаем и переходим к следующей ячейке.
4. Подсчёт соседних мин:
```go
    count := 0
    for sx := -1; sx <= 1; sx++ {
        for sy := -1; sy <= 1; sy++ {
            nx := x + sx
            ny := y + sy
            if nx >= 0 && nx < rows && ny >= 0 && ny < cols {
                if maze[nx][ny] == -1 {
                    count++
                }
            }
        }
    }
```
Пояснение:
 - Создаём переменную count для хранения количества мин вокруг текущей ячейки.
 - Два вложенных цикла sx и sy пробегают соседние позиции вокруг x, y (всего 9 позиций, включая саму ячейку).
 - nx = x + sx, ny = y + sy — координаты соседней ячейки.
 - Проверяем, что сосед не выходит за границы поля (0 ≤ nx < rows, 0 ≤ ny < cols).
 - Если соседняя ячейка заминирована (-1) — увеличиваем счётчик.
5. Запись количества мин в ячейку:
```go
	maze[x][y] = count
```
Пояснение:
 - После подсчёта всех мин вокруг текущей ячейки записываем это число в саму ячейку.
 - Если вокруг нет мин — останется 0.