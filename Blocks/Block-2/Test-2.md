# Задача 2: Функция. Выход из лабиринта.
## Условие задачи:
Дан код, который определяет, достижим ли выход из лабиринта из заданной точки старта. И если это так, выводит YES, иначе NO:

```cpp
#include <iostream>
#include <vector>
#include <string>

// Ваш код будет вставлен сюда

int main(){
    int row, col, rows, cols;
    std::cin >> row >> col >> rows >> cols;
    std::cin.ignore(1); // Игнорируем перевод строки, застрявший в потоке ввода
    
    std::vector<std::string> maze(rows);
    for(auto& line : maze) std::getline(std::cin, line);
    
    std::cout << (is_can_exit_from_maze(maze, row, col) ? "YES" : "NO") << std::endl;
}
```
Этот код будет прогоняться по тестам. Ваша задача реализовать функцию is_can_exit_from_maze таким образом, чтобы этот код стал рабочим.

Лабиринт задан в виде двумерного массива символов состоящего из rows строк и cols столбцов, например:
```
##########
#     #  E
#  ## ## #
# #     ##
#  ##### #
#  #     #
#E########
```
В лабиринте допустимы 3 типа символов:

\# (решётка) - стена, непреодолимое препятствие;
E - выход;
(пробел) - пустое пространство;
Известно, что:

По периметру лабиринта либо стена, либо выход;
Выходов может быть несколько или ни одного;
Позиция старта НЕ может быть на символе #;
Позиция с координатами 0 0 - это верхний левый угол лабиринта.
### Формат ввода
В первой строке входных данных находятся координаты точки старта, заданные двумя целыми неотрицательными числами, разделёнными пробелом. Первая координата (row) - это индекс строки; вторая координата (col) - индекс столбца.

В второй строке входных данных находятся размеры лабиринта, заданные двумя целыми числами 3 ≤ rows ≤ 10⁵ и 3 ≤ cols ≤ 10⁵, разделёнными пробелом. Первая координата (rows) - это высота лабиринта в символах; вторая координата (cols) - ширина лабиринта в символах.

В последующих rows строках задан сам лабиринт. В каждой строке могут присутствовать символы: # (решётка), E или пробел. Строки завершаются символом '\n'.
### Формат вывода
YES, если выход из лабиринта достижим из точки старта и NO, если нет.
## Решение:
```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;
bool is_can_exit_from_maze(vector<string>& maze, int row, int col) {
    if (row < 0 || row >= maze.size() || col < 0 || col >= maze[0].size()) {
        return false;
    } else if (maze[row][col] == 'E') {
        return true;
    } else if ((maze[row][col] == '#') || (maze[row][col] == '.')) {
        return false;
    } else {
        maze[row][col] = '.';
        if (is_can_exit_from_maze(maze, row-1, col) == true) {
            return true;
        }
        if (is_can_exit_from_maze(maze, row, col-1) == true) {
            return true;
        }
        if (is_can_exit_from_maze(maze, row+1, col) == true) {
            return true;
        }
        if (is_can_exit_from_maze(maze, row, col+1) == true) {
            return true;
        }
        return false;
    }
}
```
## Пояснение решения:
Библеотеки:
 - \<iostream\> - Нужно для ввода/вывода.
 - \<vector\> — чтобы хранить лабиринт в виде динамического массива строк.
 - \<string\> — для работы со строками, потому что лабиринт представлен как vector\<string\>.
1. Проверка выхода за границы:
```cpp
if (row < 0 || row >= maze.size() || col < 0 || col >= maze[0].size()) {
    return false;
}
```
Пояснение:
 - Если row или col меньше 0 или больше размеров лабиринта → за пределами карты → false.
2. Проверка выхода из лабиринта:
```cpp
else if (maze[row][col] == 'E') {
    return true;
}
```
Пояснение:
 - Если текущая ячейка равна 'E' (выход) → функция возвращает true.
3. Проверка препятствий или уже посещённых клеток:
```cpp
else if ((maze[row][col] == '#') || (maze[row][col] == '.')) {
    return false;
}
```
Пояснение:
 - Если клетка '#' (стена) или '.' (уже посещено) → false.
4. Обозначаем текущую клетку как посещённую
```cpp
else {
    maze[row][col] = '.'
```
Пояснение:
 - Чтобы не заходить туда повторно при рекурсии.
5. Рекурсивный обход соседних клеток:
```cpp
    if (is_can_exit_from_maze(maze, row-1, col) == true) {
        return true;
    }
    if (is_can_exit_from_maze(maze, row, col-1) == true) {
        return true;
    }
    if (is_can_exit_from_maze(maze, row+1, col) == true) {
        return true;
    }
    if (is_can_exit_from_maze(maze, row, col+1) == true) {
        return true;
    }
```
Пояснение:
 - Проверяем верхнюю клетку (row-1, col) → если там выход → true.
 - Проверяем левую клетку (row, col-1) → если там выход → true.
 - Проверяем нижнюю клетку (row+1, col) → если там выход → true.
 - Проверяем правую клетку (row, col+1) → если там выход → true.
6. Если ни одна из соседних клеток не ведёт к выходу → возвращаем false:
```cpp
    return false;
```