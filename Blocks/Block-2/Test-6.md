# Задача 6: Функция. Палиндром с игнорированием.
## Условие задачи:
Дана строка, состоящая из строчных и прописных символов английского алфавита, цифр, спец символов ~!@#%^&*() и пробелов. Определите, является ли эта строка палиндромом, при условии, что:

строчные и прописные символы считаются одинаковыми;
спец символы и пробелы при проверке игнорируются.
Пустую строку будем считать палиндромом.

Далее дан код который будет прогоняться по тестам. Ваша задача реализовать функцию isPalindrome таким образом, чтобы этот код стал рабочим.

```go
package main
import (
    "bufio"
    "fmt"
    "os"
)

// Ваш код будет вставлен сюда

func main() {
    line, _  := bufio.NewReader(os.Stdin).ReadString('\n')
    if isPalindrome( line[:len(line)-1] ){  // Обрезаем \n в конце строки
        fmt.Println("YES")
    }else{
        fmt.Println("NO")
    }
}

```

### Формат ввода
Строка состоящая из 1 или более символов из диапазона [0-9A-Za-z~!@#%^&*()] и пробелов. Строка завершается символом \n.


### Формат вывода
YES, если строка палиндром и NO, если нет.
## Решение:
```go
func isPalindrome(ln string) bool {
	runes := []rune(ln)
	i := 0
	j := len(runes) - 1
	for i < j {
		if runes[i] >= 'a' && runes[i] <= 'z' {
			runes[i] = runes[i] - ('a' - 'A')
		}
		if runes[j] >= 'a' && runes[j] <= 'z' {
			runes[j] = runes[j] - ('a' - 'A')
		}
		if !(runes[i] >= 'A' && runes[i] <= 'Z') {
			i++
			continue
		}
		if !(runes[j] >= 'A' && runes[j] <= 'Z') {
			j--
			continue
		}
		if runes[i] != runes[j] {
			return false
		}
		i++
		j--
	}
	return true
}
```
## Пояснение решения:
1. Cигнатура функции и подготовка:
```go
func isPalindrome(ln string) bool {
	runes := []rune(ln)
	i := 0
	j := len(runes) - 1
```
Пояснение:
 - ln string — входная строка.
 - []rune(ln) — превращаем строку в срез рун, чтобы каждый символ был отдельным элементом (важно для UTF-8).
 - i — указатель на первый символ, j — на последний.
 - Будем сравнивать символы с обоих концов строки.
2. Основной цикл:
```go
	for i < j {
```
Пояснение:
 - Цикл работает пока левый указатель меньше правого.
 - После пересечения указателей проверка завершена.
3. Нормализация регистра левого и правого символов:
```go
if runes[i] >= 'a' && runes[i] <= 'z' {
    runes[i] = runes[i] - ('a' - 'A')
}
if runes[j] >= 'a' && runes[j] <= 'z' {
    runes[j] = runes[j] - ('a' - 'A')
}
```
Пояснение:
 - Преобразуем строчные буквы в прописные, чтобы сравнение было без учёта регистра.
 - 'a' - 'A' = 32 по ASCII.
 - Если символ уже заглавный — остаётся без изменений.
4. пропуск символов слева и справа:
```go
if !(runes[i] >= 'A' && runes[i] <= 'Z') {
    i++
    continue
}
if !(runes[j] >= 'A' && runes[j] <= 'Z') {
    j--
    continue
}
```
Пояснение:
 - Если текущий символ слева не буква (спецсимвол или пробел), просто двигаем i вправо и продолжаем цикл.
 - continue пропускает остальной код на этой итерации.
 - Так же с символом справа.
5. Сравнение символов:
```go
    if runes[i] != runes[j] {
        return false
    }
```
Пояснение:
 - Если символы с двух концов не совпадают → строка не палиндром, возвращаем false.
6. сдвиг указателей:
```go
		i++
		j--
	}
```