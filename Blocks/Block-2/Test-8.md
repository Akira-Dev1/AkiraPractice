# Задача 8: Функция. Сдвиг элементов массива.
## Условие задачи:
Дан массив из 10 целых чисел и целое число steps. Выполните сдвиг всех элементов массива на steps позиций вправо или влево (если steps<0). Если элемент выходит за границу массива, то он должен попасть на его противоположную сторону.

Этот код будет прогоняться по тестам. Ваша задача реализовать функцию shift таким образом, чтобы этот код стал рабочим. Функция shift выполняет сдвиг элементов переданного ей среза.
```go
package main
import "fmt"

// Ваш код будет вставлен сюда

func main(){
    var steps int
    fmt.Scan(&steps)

    var data [10]int
    for index := range data{
        fmt.Scan(&data[index])
    }

    shift(data[:], steps);
    for _, value := range data{
        fmt.Printf("%d ", value)
    }
}

```

### Формат ввода
В первой строке входных данных указано целое число steps по модулю не превышающее 10⁹. Во второй строке перечислены 10 целых чисел в диапазоне от 10⁻⁹ до 10⁹. Числа разделены пробелом.
### Формат вывода
10 целых чисел разделённые пробелами.
## Решение:
```go
func shift(data []int, steps int) ([]int, int) {
	st := steps
	minus := false
	if steps < 0 {
		st = -steps
		minus = true
	}
	if st == len(data) {
		return data, steps
	} else if st > len(data) {
		steps %= len(data)
		if minus {
			st = -steps
		} else {
			st = steps
		}
	}
	for x := 1; x <= st; x++ {
		a := data[0]
		if minus {
			for i := 0; i < len(data); i++ {
				if i == 0 {
					a = data[9-i]
					data[9-i] = data[i]
				} else {
					b := data[9-i]
					data[9-i] = a
					a = b
				}
			}
		} else {
			for i := 1; i <= len(data); i++ {
				if i == 1 {
					a = data[i]
					data[i] = data[i-1]
				} else if i == len(data) {
					data[0] = a
				} else {
					b := data[i]
					data[i] = a
					a = b
				}
			}
		}
	}
	return data, steps
}
```
## Пояснение решения:
1. Подготовка шагов:
```go
	st := steps
	minus := false
	if steps < 0 {
		st = -steps
		minus = true
	}
```
Пояснение:
 - Если steps отрицательное, то будем сдвигать влево, иначе — вправо.
 - minus — флаг направления сдвига.
 - st — абсолютное значение количества шагов.
2. Корректировка для длин массива:
```go
	if st == len(data) {
		return data, steps
	} else if st > len(data) {
		steps %= len(data)
		if minus {
			st = -steps
		} else {
			st = steps
		}
	}
```
Пояснение:
 - Если st равно длине массива → сдвиг не изменяет массив, возвращаем как есть.
 - Если st больше длины массива → используем steps % len(data), чтобы не делать лишние циклы.
 - Обновляем st с учётом направления.
3. Внешний цикл сдвига:
```go
	for x := 1; x <= st; x++ {
		a := data[0]
```
Пояснение:
 - Сдвигаем массив по одному элементу за итерацию цикла.
 - a — временная переменная для обмена значений.
4. Cдвиг влево (steps < 0):
```go
if minus {
    for i := 0; i < len(data); i++ {
        if i == 0 {
            a = data[9-i]
            data[9-i] = data[i]
        } else {
            b := data[9-i]
            data[9-i] = a
            a = b
        }
    }
}
```
Пояснение:
 - Проходим массив с конца к началу (9-i) и переносим элементы на один шаг влево.
 - Используем временные переменные a и b для обмена значений.
 - На каждый шаг один элемент «выходит» за границу и «попадает» на противоположную сторону.
5. Cдвиг вправо (steps > 0):
```go
else {
    for i := 1; i <= len(data); i++ {
        if i == 1 {
            a = data[i]
            data[i] = data[i-1]
        } else if i == len(data) {
            data[0] = a
        } else {
            b := data[i]
            data[i] = a
            a = b
        }
    }
}
```
Пояснение:
 - Проходим массив с начала к концу.
 - На каждом шаге «сдвигаем» элемент вправо, а первый элемент переносим на конец.
 - Опять же, используются временные переменные a и b для обмена, чтобы ничего не потерять.
6. возвращаем результат:
```go
	return data, steps;
```
Пояснение:
 - После всех циклов сдвига возвращаем изменённый массив.
 - Второй аргумент (steps) не используется в основном коде, но функция возвращает его для внутренней совместимости.