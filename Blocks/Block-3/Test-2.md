# Задача 2: Валидатор скобочной последовательности.
## Условие задачи:
Дан текст (фрагмент кода или арифм. выражение), содержащая символы (, ), {, }, [ , ] и набор других символов. Необходимо определить, является ли данный тест валидным, с точки зрения баланса скобок. Остальное проверять на валидность не нужно.
Баланс скобок соблюдается, если:
 - у всех открывающих скобок есть закрывающие того же типа;
 - скобки открываются и закрываются в правильном порядке.
### Формат ввода
Текст состоящий из скобок (, ), {, }, [ , ], строчных и прописных латинских символов, спец. символов, чисел, пробелов и \n. Текст заканчивается символом !.
### Формат вывода
YES - если баланс скобок соблюдён или NO, если нет.
## Решение:
```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;
bool Check(string str) {
    vector<char> s;
    for (char c : str) {
        if (c == '(' || c == '{' || c == '[') {
            s.push_back(c);
        } else if (c == ')' || c == '}' || c == ']') {
            if (s.empty()) {
                return false;
            }
            char open = s.back();
            s.pop_back();
            if ((c == ')' && open != '(') ||
                (c == '}' && open != '{') ||
                (c == ']' && open != '[')) {
                    return false;
                }
        }
    }
    return s.empty();
}
int main() {
    string str;
    getline(cin, str, '!');
    vector<char> s;
    if (Check(str)) {
        cout << "YES";
    } else {
        cout << "NO";
    }
}
```
## Пояснение решения:
Библеотеки:
 - \<iostream\> — для ввода и вывода (cin, cout).
 - \<vector\> — динамический массив, который используем как стек для скобок.
 - \<string\> — работа со строками.

### Функция проверки баланса скобок:
```cpp
bool Check(string str) {
    vector<char> s;
    for (char c : str) {
        if (c == '(' || c == '{' || c == '[') {
            s.push_back(c);
        } else if (c == ')' || c == '}' || c == ']') {
            if (s.empty()) return false;
            char open = s.back();
            s.pop_back();
            if ((c == ')' && open != '(') ||
                (c == '}' && open != '{') ||
                (c == ']' && open != '[')) return false;
        }
    }
    return s.empty();
}
```
1. Создаём стек s для хранения открывающих скобок:
```cpp
vector<char> s;
```
2. Проходим по каждому символу строки:
```cpp
for (char c : str) {

}
```
3. Если открывающая скобка:
```cpp
    if (c == '(' || c == '{' || c == '[') {
        s.push_back(c);
    }
```
Пояснение:
 - Если это открывающая скобка ("(", "{", "[") → кладём её в стек (push_back).
4. Если закрывающая скобка:
```cpp
 else if (c == ')' || c == '}' || c == ']') {
    if (s.empty()) return false;
    char open = s.back();
    s.pop_back();
    if ((c == ')' && open != '(') ||
        (c == '}' && open != '{') ||
        (c == ']' && open != '[')) return false;
}
```
 - Проверяем пустой ли стек:
     - Если стек пуст, а встречается закрывающая скобка → нечего закрывать → строка невалидна (false).
 - Берём последнюю открытую скобку:
     - open = s.back() — смотрим верхнюю скобку в стеке.
     - s.pop_back() — убираем её из стека, потому что она будет закрыта.
 - Сравниваем тип скобки:
     - Например, если c = ')', а open не '(' → это ошибка → false.
     - Идея: закрывающая скобка должна точно соответствовать последней открытой.

### Основная программа:
```cpp
int main() {
    string str;
    getline(cin, str, '!');
    if (Check(str)) cout << "YES"; else cout << "NO";
}
```
Пояснение:
 - Считывает всю строку до символа !.
 - Передаёт строку в Check.
 - Если Check вернула true → выводим "YES".
 - Если Check вернула false → выводим "NO".
